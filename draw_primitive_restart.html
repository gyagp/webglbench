<!doctype html>
<html>
  <label id = "fps">fps</label>
  <body>
    <canvas width = "1370" height = "970" id = "my_Canvas"></canvas>
    <script>
      var instanceNum = 15;  //The nubmer of fans to draw
      var vertCode =
        '#version 300 es\n' + 
        'precision highp float;\n' +
        'precision highp int;\n' +
        'uniform mat4 moveMatrix;\n' +
        'uniform vec3 center;\n' +
        'layout(location = 0) in vec3 pos;\n' +
        'in vec3 pColor;\n' +
        'out vec3 fragColor;\n' +
        'void main()\n' +
        '{\n' +
            'fragColor = pColor;\n' +
            'gl_Position = moveMatrix * vec4(pos + center, 1.0);\n' +
        '}\n';
      // Fragment shader program
      var fragCode =
        '#version 300 es\n' +
        'precision highp float;\n' +
        'precision highp int;\n' +
        'in vec3 fragColor;\n' +
        'out vec4 color;\n' +

        'void main()\n' +
        '{\n' +
            'color = vec4(fragColor, 1.0);\n' +
        '}\n';

      var canvas = document.getElementById('my_Canvas');
      gl = canvas.getContext('webgl2');
      var canvas = document.createElement('canvas');
      var vertShader = gl.createShader(gl.VERTEX_SHADER);
      // Attach vertex shader source code
      gl.shaderSource(vertShader, vertCode);
      // Compile the vertex shader
      gl.compileShader(vertShader);
      var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
      // Attach fragment shader source code
      gl.shaderSource(fragShader, fragCode);
      // Compile the fragmentt shader
      gl.compileShader(fragShader);
      // Create a shader program object to store
      // the combined shader program
      var shaderProgram = gl.createProgram();
      // Attach a vertex shader
      gl.attachShader(shaderProgram, vertShader);
      // Attach a fragment shader
      gl.attachShader(shaderProgram, fragShader);
      // Link both the programs
      gl.linkProgram(shaderProgram);
      // Use the combined shader program object
      gl.useProgram(shaderProgram);

        // -- Init Buffer
      var scale = 1.0 / Math.sqrt(instanceNum);
      var vertices = new Float32Array([
        0.0,  0.0,  0.15 * scale, 0.1, 0.1, 0.1,
        0.0,  0.0, -0.15 * scale, 0.1, 0.1, 0.1,
        scale * Math.cos(30.0 * (Math.PI / 180.0) ),  scale * Math.sin(30.0 * (Math.PI / 180.0)),  scale * 0.15, 1.0, 0.0, 0.0,
        scale * Math.cos(30.0 * (Math.PI / 180.0)),  scale * Math.sin(30.0 * (Math.PI / 180.0)),  scale * -0.15, 1.0, 0.0, 0.0,
        scale * Math.cos(60.0 * (Math.PI / 180.0)),  scale * Math.sin(60.0 * (Math.PI / 180.0)),  scale * 0.15, 0.0, 1.0, 0.0,
        scale * Math.cos(60.0 * (Math.PI / 180.0)),  scale * Math.sin(60.0 * (Math.PI / 180.0)),  scale * -0.15, 0.0, 1.0, 0.0,
        scale * Math.cos(90.0 * (Math.PI / 180.0)),  scale * Math.sin(90.0 * (Math.PI / 180.0)),  scale * 0.15, 0.0, 0.0, 1.0,
        scale * Math.cos(90.0 * (Math.PI / 180.0)),  scale * Math.sin(90.0 * (Math.PI / 180.0)),  scale * -0.15, 0.0, 0.0, 1.0,
        scale * Math.cos(120.0 * (Math.PI / 180.0)),  scale * Math.sin(120.0 * (Math.PI / 180.0)),  scale * 0.15, 1.0, 1.0, 0.0,
        scale * Math.cos(120.0 * (Math.PI / 180.0)),  scale * Math.sin(120.0 * (Math.PI / 180.0)),  scale * -0.15, 1.0, 1.0, 0.0,
        scale * Math.cos(150.0 * (Math.PI / 180.0)),  scale * Math.sin(150.0 * (Math.PI / 180.0)),  scale * 0.15, 0.0, 1.0, 1.0,
        scale * Math.cos(150.0 * (Math.PI / 180.0)),  scale * Math.sin(150.0 * (Math.PI / 180.0)),  scale * -0.15, 0.0, 1.0, 1.0,
        scale * Math.cos(180.0 * (Math.PI / 180.0)),  scale * Math.sin(180.0 * (Math.PI / 180.0)),  scale * 0.15, 1.0, 0.0, 1.0,
        scale * Math.cos(180.0 * (Math.PI / 180.0)),  scale * Math.sin(180.0 * (Math.PI / 180.0)),  scale * -0.15, 1.0, 0.0, 1.0,
        scale * Math.cos(210.0 * (Math.PI / 180.0) ),  scale * Math.sin(210.0 * (Math.PI / 180.0)),  scale * 0.15, 1.0, 0.0, 0.0,
        scale * Math.cos(210.0 * (Math.PI / 180.0)),  scale * Math.sin(210.0 * (Math.PI / 180.0)),  scale * -0.15, 1.0, 0.0, 0.0,
        scale * Math.cos(240.0 * (Math.PI / 180.0)),  scale * Math.sin(240.0 * (Math.PI / 180.0)),  scale * 0.15, 0.0, 1.0, 0.0,
        scale * Math.cos(240.0 * (Math.PI / 180.0)),  scale * Math.sin(240.0 * (Math.PI / 180.0)),  scale * -0.15, 0.0, 1.0, 0.0,
        scale * Math.cos(270.0 * (Math.PI / 180.0)),  scale * Math.sin(270.0 * (Math.PI / 180.0)),  scale * 0.15, 0.0, 0.0, 1.0,
        scale * Math.cos(270.0 * (Math.PI / 180.0)),  scale * Math.sin(270.0 * (Math.PI / 180.0)),  scale * -0.15, 0.0, 0.0, 1.0,
        scale * Math.cos(300.0 * (Math.PI / 180.0)),  scale * Math.sin(300.0 * (Math.PI / 180.0)),  scale * 0.15, 1.0, 1.0, 0.0,
        scale * Math.cos(300.0 * (Math.PI / 180.0)),  scale * Math.sin(300.0 * (Math.PI / 180.0)),  scale * -0.15, 1.0, 1.0, 0.0,
        scale * Math.cos(330.0 * (Math.PI / 180.0)),  scale * Math.sin(330.0 * (Math.PI / 180.0)),  scale * 0.15, 0.0, 1.0, 1.0,
        scale * Math.cos(330.0 * (Math.PI / 180.0)),  scale * Math.sin(330.0 * (Math.PI / 180.0)),  scale * -0.15, 0.0, 1.0, 1.0,
        scale * Math.cos(360.0 * (Math.PI / 180.0)),  scale * Math.sin(360.0 * (Math.PI / 180.0)),  scale * 0.15, 1.0, 0.0, 1.0,
        scale * Math.cos(360.0 * (Math.PI / 180.0)),  scale * Math.sin(360.0 * (Math.PI / 180.0)),  scale * -0.15, 1.0, 0.0, 1.0,
      ]);

      function rotateZ(m, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var mv0 = m[0], mv4 = m[4], mv8 = m[8];
                
        m[0] = c*m[0]-s*m[1];
        m[4] = c*m[4]-s*m[5];
        m[8] = c*m[8]-s*m[9];

        m[1]=c*m[1]+s*mv0;
        m[5]=c*m[5]+s*mv4;
        m[9]=c*m[9]+s*mv8;
      }

      function rotateX(m, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var mv1 = m[1], mv5 = m[5], mv9 = m[9];
                
        m[1] = m[1]*c-m[2]*s;
        m[5] = m[5]*c-m[6]*s;
        m[9] = m[9]*c-m[10]*s;

        m[2] = m[2]*c+mv1*s;
        m[6] = m[6]*c+mv5*s;
        m[10] = m[10]*c+mv9*s;
      }

      function rotateY(m, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var mv0 = m[0], mv4 = m[4], mv8 = m[8];
                
        m[0] = c*m[0]+s*m[2];
        m[4] = c*m[4]+s*m[6];
        m[8] = c*m[8]+s*m[10];

        m[2] = c*m[2]-s*mv0;
        m[6] = c*m[6]-s*mv4;
        m[10] = c*m[10]-s*mv8;
      }

      var vertexPosBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
        
      var MAX_UNSIGNED_SHORT = 65535;
      var indices = new Uint16Array([
        0, 1, 2, 3,  MAX_UNSIGNED_SHORT, 0, 1, 4, 5, MAX_UNSIGNED_SHORT, 0, 1, 6, 7, MAX_UNSIGNED_SHORT, 0, 1, 8, 9, MAX_UNSIGNED_SHORT, 0, 1, 10, 11, MAX_UNSIGNED_SHORT, 0, 1, 12, 13,
        0, 1, 14, 15,  MAX_UNSIGNED_SHORT, 0, 1, 16, 17, MAX_UNSIGNED_SHORT, 0, 1, 18, 19, MAX_UNSIGNED_SHORT, 0, 1, 20, 21, MAX_UNSIGNED_SHORT, 0, 1, 22, 23, MAX_UNSIGNED_SHORT, 0, 1, 24, 25,
      ]);
      var vertexElementBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexElementBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

      // -- Init Vertex Array
      var vertexArray = gl.createVertexArray();
      gl.bindVertexArray(vertexArray);
      var moveMatrix =[1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
      rotateZ(moveMatrix, 0.4);
      rotateY(moveMatrix, 0.4);
      rotateX(moveMatrix, 0.4);

      var instanceCenter = [0.3, 0.2, 0.4];
      var moveMat = gl.getUniformLocation(shaderProgram, "moveMatrix");
      var center = gl.getUniformLocation(shaderProgram, "center");
      var vertexPosLocation = 0;

      gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
      gl.enableVertexAttribArray(vertexPosLocation);
      gl.vertexAttribPointer(vertexPosLocation, 3, gl.FLOAT, false, 24, 0);
      var colors = gl.getAttribLocation(shaderProgram, "pColor");
      gl.enableVertexAttribArray(colors);
      gl.vertexAttribPointer(colors, 3, gl.FLOAT, false, 24, 12);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
        
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexElementBuffer);

      gl.bindVertexArray(null);
      gl.enable(gl.DEPTH_TEST);
        // -- Render
      gl.clearColor(1.0, 1.0, 1.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      var instanceCenter = [];
      for(var ii = 0; ii<instanceNum; ++ii){
        instanceCenter. push(Math.random() * 1.8 - 1);
        instanceCenter. push(Math.random() * 1.8 - 1);
        instanceCenter. push(Math.random() * 1.8 - 1);
      }

      var draw = function(){
        gl.clear(gl.COLOR_BUFFER_BIT);
        rotateZ(moveMatrix, 0.01);
        rotateY(moveMatrix, 0.01);
        rotateX(moveMatrix, 0.01);
        for(var ii = 0; ii<instanceNum; ++ii){
          gl.uniformMatrix4fv(moveMat, false, moveMatrix);
          gl.uniform3f(center, instanceCenter[0 + ii * 3], instanceCenter[1 + ii * 3], instanceCenter[2 + ii * 3]);
          gl.bindVertexArray(vertexArray);
          gl.drawElements(gl.TRIANGLE_STRIP, indices.length , gl.UNSIGNED_SHORT, 0);
        }

      }
      var fps = 0;
      var formatIndex = 0;
      var tick = function() {
        draw();   
        fps = fps + 1;
        requestAnimationFrame(tick, canvas);
      };
    tick();
    var fpsOut = document.getElementById('fps');

    setInterval(function(){
                            fpsOut.innerHTML = fps.toFixed(1) + " fps";
                            fps = 0;
                          }
                ,1000);
    </script>
  </body>
</html>
